# Go依赖注入

## google-wire

wire 是编译代码时生成代码的依赖注入，是编译期间注入依赖代码（compile-time dependency injection）。而且代码生成期间，如果依赖注入有问题，生成依赖代码时就会出错，就可以报出问题来，而不必等到代码运行时才暴露出问题。

* `provider`：提供一个对象。
* `injector`：负责根据对象依赖关系，生成新程序。

```bash
# 安装
go get github.com/google/wire/cmd/wire
```

* wire 结构体和方法列表

```go
// 参数是 provider 不定长列表。 把所有相关的 provider 组织在一起然后生成 injector 函数代码。它是生成 injector 函数的模板函数。
func Build(...interface{}) string
// 绑定接口实现
type Binding
	func Bind(iface, to interface{}) Binding
type ProvidedValue
	func InterfaceValue(typ interface{}, x interface{}) ProvidedValue
	func Value(interface{}) ProvidedValue
// 整合provide
type ProviderSet
	func NewSet(...interface{}) ProviderSet
type StructFields
	func FieldsOf(structType interface{}, fieldNames ...string) StructFields
// 生成结构体provide
type StructProvider
	func Struct(structType interface{}, fieldNames ...string) StructProvider
```

### provider

provider 是一个普通的 Go 函数 ，可以理解为是一个对象的构造函数。为下面生成 injector 函数提供”构件“。

下面的 `NewUserStore()` 函数可以看作是一个 `provider`。这个函数需要传入 `*Config` 和 `*mysql.DB` 2 个参数。
```go
// NewUserStore 是一个 provider for *UserStore，*UserStore 依赖 *Config，*mysql.DB
func NewUserStore(cfg *Config, db *mysql.DB) (*UserStore, error) {... ...}

// NewDefaultConfig 是一个 provider for *Config，没有任何依赖
func NewDefaultConfig() *Config {...}

// NewDB 是 *mysql.DB 的一个 provider ，依赖于数据库连接信息 *ConnectionInfo
func NewDB(info *ConnectionInfo) (*mysql.DB, error){...}
```
provider 可以组合成一组 `provider set`。对于经常在一起使用的 providers 来说，这个非常有用。使用 `wire.NewSet` 方法可以把他们组合在一起，
```go
var SuperSet = wire.NewSet(NewUserStore, NewDefaultConfig)
```
也可以把其他的 provider sets 加入一个 provider set
```go
import （
    “example.com/some/other/pkg”
）

// ... ...
var MegaSet = wire.NewSet(SuperSet, pkg.OtherSet)
```

### injector
编写生成 injector 的签名函数，然后用 wire 命令生成相应的函数。wire 命令会按照依赖顺序调用 providers 生成更加完整的函数，这个就是 injector。

```go
// +build wireinject

func initUserStore(info *ConnectionInfo) (*UserStore, error) {
    wire.Build(SuperSet, NewDB) // 声明获取 UserStore 需要调用哪些 provider 函数
    return nil, nil
}
```
然后用 wire 命令把上面的 initUserStore 函数生成 injector 函数，生成的函数对应文件名 `wire_gen.go`。

### 使用示例

* 简单例子

```go
package main

import (
	"context"
	"errors"
)

type Student struct {
	ClassNo int
}

// NewStudent 就是一个 provider，返回一个 Student
func NewStudent() Student {
	return Student{ClassNo: 10}
}

type Class struct {
	ClassNo int
}

// NewClass 就是一个 provider，返回一个 Class
func NewClass(stu Student) Class {
	return Class{ClassNo: stu.ClassNo}
}

type School struct {
	ClassNo int
}

// NewSchool 是一个 provider，返回一个 School
// 与上面 provider 不同的是，它还返回了一个错误信息
func NewSchool(ctx context.Context, class Class) (School, error) {
	if class.ClassNo == 0 {
		return School{}, errors.New("cannot provider school when class is 0")
	}
	return School{ClassNo: class.ClassNo}, nil
}

//////////  wire.go
// +build wireinject    这一行代码一定要在包最上面声明，表明这是一个准备被编译的 injecto

package main

import (
	"github.com/google/wire"
)

var SuperSet = wire.NewSet(NewStudent, NewClass, NewSchool)

func initSchool(ctx context.Context) (School, error) {
	wire.Build(SuperSet)
	return School{}, nil
}

//////////// wire_gen.go 
// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//+build !wireinject

package main

import (
	"context"
	"github.com/google/wire"
)

// Injectors from wire.go:

func initSchool(ctx context.Context) (School, error) {
	student := NewStudent()
	class := NewClass(student)
	school, err := NewSchool(ctx, class)
	if err != nil {
		return School{}, err
	}
	return school, nil
}

// wire.go:

var SuperSet = wire.NewSet(NewStudent, NewClass, NewSchool)
```

* 接口示例

```go
type Fooer interface {
    Hello()
}

type Foo struct{}

func (f Foo)Hello() {
    fmt.Println("hello")
}

func Bar struct{}

func NewBar() Bar {
    return Bar{}
}

///////////////// wire
var bind = wire.Bind(new(Fooer), new(Foo))
var set = wire.NewSet(bind, NewBar)

// or
var set = wire.NewSet(wire.Bind(new(Fooer), new(Foo)), NewBar)
```

* 结构体示例

```go
type Foo int
type Bar int

func NewFoo() Foo {/* ... */}
func NewBar() Bar {/* ... */}

type FooBar struct {
    MyFoo Foo
    MyBar Bar
}

// 结构体的 provider 仅仅是用作字段赋值，那么可以使用函数 wire.Struct 来赋值
var set = wire.NewSet(
	NewFoo,
    NewBar,
    // 直接使用wire.Struct作为结构提的provide
    wire.Struct(new(FooBar), "MyFoo", "MyBar"),
)
```

## Uber-dig

使用反射实现的依赖注入

添加引用

```bash
go get github.com/uber-go/dig
```
使用示例
```go
// 构建一个DI容器
func BuildContainer() *dig.Container {
  container := dig.New()
  // 注入config的实例化方法
  container.Provide(NewConfig)
  // 注入database的实例化方法
  container.Provide(ConnectDatabase)
  // 注入repository的实例化方法
  container.Provide(repo.NewPersonRepository)
  // 注入service的实例化方法
  container.Provide(service.NewPersonService)
  // 注入server
  container.Provide(NewServer)

  return container
}

func main() {
  container := BuildContainer()
  
  err := container.Invoke(func(server *Server) {
    server.Run()
  })

  if err != nil {
    panic(err)
  }
}
```

下面是对main函数里基础服务注入的流程说明：

* `BuildContainer`，只将各个基础服务的实例化方法注入到容器里，还没有调用这些方法来实例化基础服务
* `container.Invoke`,这里将会从容器里寻找`server`实例，来运行`server.Run()`。如果实例不存在，则调用其实例化的方法，也就是`NewServer`
* 因为`NewServer(config *config.Config, service *service.PersonService) *Server`依赖于`config.Config`和`service.PersonService`，故触发`NewConfig`和`NewPersonService`方法。
* `NewConfig`不依赖于任何实例，故可以成功返回`config.Config`实例。
* `NewPersonService(config *config.Config, repository *repo.PersonRepository) *PersonService`依赖`config.Config`和`repo.PersonRepository`,继而触发`repo.NewPersonRepository`去实例化`repo.PersonRepository`
* `repo.NewPersonRepository`方法依赖于`db`,故触发`ConnectDatabase`方法，用来连接数据库，实例化`db`实例
* 最后递归倒推回去，完成所有实例的初始化与注入，调用`server.Run()`方法启动`http`服务。

**注意**: 有依赖的初始化方法，需要放在前置依赖注入之后，比如`container.Provide(ConnectDatabase)`就放在`container.Provide(NewConfig)`之后。如果找不到初始化需要的依赖对象，在Invoke时就会报错。
