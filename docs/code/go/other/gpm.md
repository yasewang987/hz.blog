# Go-GPM解析

## 用户态和内核态

Linux整个体系分为用户态和内核态(或者叫用户空间和内核空间)， 那内核态究竟是什么呢?

本质上我们所说的内核态， 它是一种特殊的软件程序，统筹计算机的硬件资源，例如协调CPU资源、分配内存资源、并且提供稳定的环境供应用程序运行。

![gpm1](http://cdn.go99.top/docs/code/go/gpm1.image)

## 为什么线程切换会导致用户态和内核态的切换？

* 线程是cpu调度的基本单位，进程是资源占有的基本单位。

* 因为`线程中的代码是在用户态运行`，而`线程的调度是在内核态`，所以线程切换会触发用户态和内核态的切换。

* 线程上下文切换的代价是高昂的：上下文切换的延迟取决于不同的因素，大概是50到100 ns左右，考虑到硬件平均在每个核心上每ns执行12条指令，那么一次上下文切换可能会花费600到1200条指令的延迟时间。

## 导致线程上下文切换的时机

* 自发性上下文切换
    1. `Thread.sleep()`: 线程主动休眠
    1. `object.wait()`: 线程等待锁
    1. `Thread.yield()`: 当前线程主动让出CPU，如果有其他就绪线程就执行其他线程，如果没有则继续当前线程
    1. `oThread.join()`: 阻塞发起调用的线程，直到oThread执行完毕
* 非自发性上下文切换
    1. 线程的时间片用完
    1. 高优先级线程抢占
    1. 虚拟机的垃圾回收动作

## 线程切换的开销

* 直接开销
    1. 保存/恢复上下文所需的开销
    1. 线程调度器调度线程的开销
* 间接开销
    1. 重新加载高速缓存
    1. 上下文切换可能导致 一级缓存被冲刷，写入下一级缓存或内存

![gpm2](http://cdn.go99.top/docs/code/go/gpm2.image)

## go的协程轻量级体现在哪？

如上面所述，线程切换会导致 用户态和内核态的切换，其中内核态耗时较长，且不受用户代码控制。

go将`goroutine`的调度维持在用户态， 这是由`GPM`中的`P Process`来完成的，做用户态任务的调度器，功能类比于常规的操作系统线程调度器，所以又被称为逻辑处理器。

![gpm3](http://cdn.go99.top/docs/code/go/gpm3.image)

`P` 是`G、M`之间的桥梁，调度器对于`goroutine`的调度，很明显也会有切换，这个切换是很轻量的： 只涉及PC SP DX三个寄存器的值的修改；而对比线程的上下文切换则需要陷入内核模式、以及16个寄存器的刷新。

## GO GMP 调度方式

* 由逻辑处理器`P`调度协程`G`进系统线程`M` (若本地队列没有`G`，从其他队列/全局队列偷取`G`)，
* 线程`M`执行`G`， 遇到`系统调用`, `G`和`M`分离，拿新的`M`去接管原逻辑处理器`P`.

![gpm4](http://cdn.go99.top/docs/code/go/gpm4.image)


